---
title: 'Advanced Scripting'
description: 'Master complex interactions with MidInt intentions'
icon: 'scroll'
---

## Beyond Deployment

MidInt's unique "intention" execution model allows for powerful scripting that goes beyond simple one-off transactions. By using `hre.midl`, you can chain operations and manage states efficiently.

### 1. The Intention lifecycle

In MidInt, transactions are first queued as "intentions" and then executed. This is handled by the `hre.midl` object in Hardhat.

```javascript
// 1. Initialize the MIDL context
await hre.midl.initialize();

// 2. Queue an intention
await hre.midl.execute({
    name: "MyTask",
    address: CONTRACT_ADDRESS,
    functionName: "myFunction",
    args: [arg1, arg2],
});

// 3. Execute all queued intentions
await hre.midl.execute();
```

### 2. Chaining Operations

You can queue multiple intentions and execute them sequentially in a single script. For example, approving and then adding liquidity:

```javascript
await hre.midl.execute({
    name: "ApproveTBTC",
    address: TBTC,
    functionName: "approve",
    args: [ROUTER, amount],
});

await hre.midl.execute({
    name: "AddLiquidity",
    address: ROUTER,
    functionName: "addLiquidity",
    // ... args
});

// Both will be executed in order
await hre.midl.execute();
```

### 3. Reading State with `hre.midl.read`

While you can use standard `ethers` for reading, `hre.midl.read` provides a consistent interface within the MidInt runtime.

```javascript
const balance = await hre.midl.read({
    address: TBTC,
    functionName: "balanceOf",
    args: [userAddress],
});
```

### 4. Custom Task Examples

You can find advanced script examples in the `contracts/scripts` directory:
- `faucet.ts`: Selective minting logic.
- `custom-swap.ts`: Pre-calculated swap paths and slippage.

---

## Technical Deep Dive

To learn more about how MIDL handles intentions at the protocol level, visit the [official MIDL documentation](https://js.midl.xyz).
